from keras.models import Sequential
from ..dataset_processing.src.model.scenario.scenariogenerator import ScenarioGenerator
from .io.nntraininginputset import NNTrainingInputSet

from keras.layers import Dense
from threading import RLock
import numpy as np
import logging
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

class NN(object):
    """ Neural network class (Thread-safe) """

    ## Constants ##
    #SEED = 7
    NN_INPUTS = 5 # {user_nationality_mapped, user_sex_mapped, user_age, product_category_mapped, product_avg_rating}
    NN_OUTPUTS = 1 # {like_probability}
    NN_DEFAULT_EPOCHS = 1
    NN_DEFAULT_BATCH_SIZE = 500
    NETWORK = None # Neural Network built upon a Keras model
    ## Class random init ##
    #np.random.seed(SEED)
    RLOCK = RLock()

    @staticmethod
    def instantiateNN(trainingInputSet=None, rules=None):
        """Returns a newly created NN object, trained if rules are specified
        """
        network = NN()
        network.createModel()
        if trainingInputSet:
            network.setTrainingInputSet(trainingInputSet)
        elif rules:
            network.trainWithRandomScenario(rules=rules)
        return network

    @staticmethod
    def getInstance(rules=False):
        """ Singleton method to get the only instance
        """
        if (NN.NETWORK is None):
            NN.RLOCK.acquire()
            if (NN.NETWORK is None):
                NN.NETWORK = NN.instantiateNN(rules=rules)
            NN.RLOCK.release()
        return NN.NETWORK

    @staticmethod
    def setInstance(newNetwork):
        """Will swap the active Neural Network"""
        # Lock to avoid changing it while attending petitions
        NN.RLOCK.acquire()
        NN.NETWORK = newNetwork
        NN.RLOCK.release()

    @staticmethod
    def trainNewInstance(realData=False, rules=None):
        newNetwork = NN.instantiateNN(rules=rules)
        newNetwork.trainModel()
        NN.setInstance(newNetwork)

    @staticmethod
    def resetNetwork():
        """ Creates a new class instance for the network
        """
        NN.NETWORK = None
        NN.getInstance()

    def trainWithRandomScenario(self, rules=None):
        """ This method creates a random scenario combining sets of predective rules
            in order to generate a combination of users and products with hidden patterns.
            The training output generated by the scenario is then used to train the NN.
        """
        logger.info('Generating random scenario')
        nnTrainingInputSet = ScenarioGenerator.generateTrainingInputSet(rules=rules)
        self.setTrainingInputSet(nnTrainingInputSet)
        self.trainModel()

    def trainWithRealData(self):
        pass

    def createModel(self):
        NN.RLOCK.acquire()
        self._model = Sequential()
        self._model.add(Dense(100, input_dim=NN.NN_INPUTS, init='normal', activation='relu')) #Dense = Fully Connected ; uniform = 0 - 0.05
        self._model.add(Dense(80, init='normal', activation='relu'))
        self._model.add(Dense(NN.NN_OUTPUTS, init='normal', activation='sigmoid'))
        # Compile model
        self._model.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy']) #Adam = efficient gradient descent
        NN.RLOCK.release()

    def trainModel(self, nb_epoch=NN_DEFAULT_EPOCHS, batch_size=NN_DEFAULT_BATCH_SIZE):
        NN.RLOCK.acquire()
        self._model.fit(self.getTrainingInput(), self.getTrainingOutput(), nb_epoch=nb_epoch, batch_size=batch_size)
        NN.RLOCK.release()

    def evaluate(self, nn_input, nn_output):
        """ Evaluates the network's accuracy
        """
        NN.RLOCK.acquire()
        scores = self._model.evaluate(nn_input, nn_output)
        logger.info("%s: %.2f%%" % (self._model.metrics_names[1], scores[1]*100))
        NN.RLOCK.release()
        return scores

    def predict(self, nn_input):
        """ Predicts the like value for the given input
            ev_X --> nn input in shape numpy[[user_nationality_mapped, user_sex_mapped, user_age, product_category_mapped]]
            returns --> nn output in shape numpy[[like0],[like1],..,[liken-1]] / like = float value between [0., 1.] (where '1.' is better)
        """
        NN.RLOCK.acquire()
        prediction = self._model.predict(nn_input)
        NN.RLOCK.release()
        return prediction

    def setTrainingInputSet(self, trainingInputSet):

        if ((trainingInputSet == None) or (not isinstance(trainingInputSet, NNTrainingInputSet))):
            raise TypeError('trainingInputSet object must be of type TrainingInputSet')
        else:
            NN.RLOCK.acquire()
            logger.debug(trainingInputSet.getInput())
            self._traningInputSet = trainingInputSet
            NN.RLOCK.release()

    def getTrainingInput(self):
        return self._traningInputSet.getInput()

    def getTrainingOutput(self):
        return self._traningInputSet.getOutput()

    def getRule(self, nationality, category):
        if self._traningInputSet is None or self._traningInputSet._rule_dic is None:
            logger.warning("No rules could be found for (NAT=%s, CAT=%s)" % (nationality, category))
            return None
        return self._traningInputSet._rule_dic[(nationality, category)]

    def __init__(self, trainingInputSet = None):
        self._model = None
        self._traningInputSet = NNTrainingInputSet()
